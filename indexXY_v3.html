<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map 1</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <link href="https://unpkg.com/normalize.css@8.0.1/normalize.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
        integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
        crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <style>
        body,
        html {
            height: 100%;
            box-sizing: border-box;
            font-size: 62.5%;

        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            background: url(fon.png);
            background-repeat: round;
            background-size: auto;
            background-attachment: fixed;
            object-fit: cover;
        }

        #map {
            width: 102rem;
            height: 50rem;
            margin-top: 1.5rem;
            background: transparent;

        }

        input {
            margin-top: 5px;
        }

        .my-label {
            position: absolute;
            width: 80px;
            height: 30px;
            font-size: 1.8rem;
            color: #04a1fc;
            text-align: center;
            border: 1px solid blue;
        }

        .my_border {
            border: 1px solid red;
        }

        .map__section {
            display: flex;
            justify-content: center;
        }

        .outer_container {
            flex: 1 0 auto;
        }

        .container {
            max-width: 1020px;
            margin: 0 auto;
        }

        .head__section_data {
            padding: 25px 0;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .logo {
            text-align: center;
            font-size: 20px;
            color: white;
            background-color: #66339a;
            font-weight: 900;
            padding: 10px;
        }

        .info__section_data {
            color: rgba(58, 53, 53, 0.808);
            font-size: 1.4rem;
            line-height: 1.7;
        }

        .search__section_data {
            text-align: center;
        }

        .search_bar {
            position: relative;
            margin: 0 auto;
            width: 630px;
        }

        #id_pixel_input {
            width: 100%;
            font-size: 2rem;
            color: #000;
            font-weight: 500;
            border-radius: 25px;
            background-color: #fff;
            outline: none;
            border: 0;
            text-align: center;
            height: 5rem;
        }

        #id_go {
            position: absolute;
            width: 120px;
            top: 4px;
            right: 0;
            height: 44px;
            background-color: #000;
            color: #fff;
            font-weight: 500;
            font-size: 15px;
            padding: 5px;
            border-radius: 20px;
            border: transparent;
        }

        .id__controls {
            display: none;
        }

        .footer__section {}

        .footer__data {
            padding: 1rem;
            text-align: center;
        }

        .created {
            font-size: 1.6rem;
            color: rgba(11, 13, 160, 0.808);
            font-weight: 500;

        }

        .leafle-control {
            display: none;
        }

        .hide-leaflet-logo {
            display: none;
        }

        .email {
            font-size: 1.4rem;
        }

        input:focus::placeholder {
            color: transparent;
        }
    </style>
</head>

<body>
    <div class="outer__container">

        <div class="head__section">
            <div class="head__section_data  container">
                <div class="logo">LOGO</div>
                <div class="email">info@gmail.com</div>
            </div>
        </div>
        <div class="info__section">
            <div class="info__section_data container">
                <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Distinctio quod eos odit numquam enim!
                    Corrupti,
                    ullam neque laboriosam provident eligendi soluta reprehenderit quo molestias consectetur vero,
                    maiores fugit corporis nostrum! Lorem ipsum dolor sit amet consectetur adipisicing elit. Eveniet
                    voluptas aliquam repellat! Cupiditate unde esse voluptatibus nostrum hic aliquid, necessitatibus
                    facere, praesentium natus odio ipsum. Eius optio exercitationem aliquam hic.</p>
            </div>
        </div>
        <div class="search__section">
            <div class="search__section_data container">
                <div class="search_bar">
                    <input type="text" id="id_pixel_input" placeholder="Enter your number of pixel">
                    <input type="button" value="Search" id="id_go" onclick="drawIDPoint(5)">
                </div>
            </div>
        </div>


        <div class="map__section container">
            <div id="map"></div>
        </div>
        <footer class="footer__section">
            <div class="footer__data container">
                <div class="created">Created by Fox</div>
            </div>
        </footer>
    </div>

    <script>
        var map;
        var canvaEl = document.getElementById("map")
        var myMarker;
        var myGreenPinMarker;

        const svgIcon = L.divIcon({
            html: `
            <div class="_my_border">
                <?xml version="1.0" encoding="utf-8"?>
<svg version="1.1" id="Слой_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 21 58.9" style="enable-background:new 0 0 21 58.9;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#2A37A9;}
	.st1{fill:#2A36A8;}
	.st2{fill:#FFFFFF;}
	.st3{fill:#5E68D2;}
</style>
<g>
	<polygon class="st3" points="10.5,58.8 4.5,7.3 16.4,7.3 	"/>
	<circle class="st3" cx="10.5" cy="10.4" r="10.4"/>
</g>
</svg>

                </div>`,
            className: "",
            iconSize: [20, 52],
            iconAnchor: [10, 52],
        });

        var greenIcon = L.icon({
            iconUrl: 'pin.png',
            shadowUrl: 'pin.png',

            iconSize: [38, 95], // size of the icon
            shadowSize: [38, 95], // size of the shadow
            iconAnchor: [19, 95], // point of the icon which will correspond to marker's location
            shadowAnchor: [19, 95],  // the same for the shadow
            popupAnchor: [-3, -76] // point from which the popup should open relative to the iconAnchor
        });

        let circle_rows_array = []
        let virtual_circle_model = []

        var image_width = 5171, image_height = 5171;
        var minZoom = -4, maxZoom = 6;
        var resetPositionZoom = -1
        var circle_center_x = 5170 / 2, circle_center_y = 5170 / 2, circle_diameter = 5170;
        //circle_center_x та circle_center_y - координати Leaflet


        var showGridByZoom = 5
        var showZoomedPixelDelay = 3 //sec
        var markersOnLayer = []
        var squaresOnLayer = []
        var crossOnLayer = []
        var circleOnLayer = []
        var markersLayerGroup = L.layerGroup(markersOnLayer)
        var squaresLayerGroup = L.layerGroup(squaresOnLayer)
        var crossLayerGroup = L.layerGroup(crossOnLayer)
        var circleLayerGroup = L.layerGroup(circleOnLayer)

        var gridLinesOnLayer = []
        var gridLayerGroup = L.layerGroup(gridLinesOnLayer)
        var showGrid = false;
        var showCross = false;
        var showCircle = false;
        //--------------------------------------------


        var yx = L.latLng;
        var xy = function (x, y) {
            if (L.Util.isArray(x)) {    // When doing xy([x, y]);
                return yx(x[1], x[0]);
            }
            return yx(y, x);  // When doing xy(x, y);
        };

        document.getElementById("id_pixel_input")
            .addEventListener('change', (e) => {
                drawIDPoint(maxZoom)
            });



        function initLMap() {

            var imgDimensions = { width: image_width, height: image_height } //this is the height and width of the image. It hasn't been loaded yet.

            map = L.map('map', {
                maxZoom: maxZoom,
                minZoom: minZoom,
                crs: L.CRS.Simple,
                center: [circle_center_x, circle_center_y],
                //keyboard: false,
                //zoomControl: false,
                layers: [markersLayerGroup, squaresLayerGroup, gridLayerGroup, crossLayerGroup, circleLayerGroup]
            })
            //map.setView([imgDimensions.height / 2, imgDimensions.width / 2], 0);


            //var imageUrl = 'https://media.istockphoto.com/vectors/bitcoin-internet-money-icon-vector-vector-id1139020309?k=20&m=1139020309&s=612x612&w=0&h=Y72ip4Gf2khJU5xYG9AO9sNmM-S_l-h7Ie7hOaaHDKs='
            //var imageUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Bitcoin.svg/768px-Bitcoin.svg.png'
            //var imageUrl = 'http://127.0.0.1:8000/Logo_Bitcoin72ppi.png'
            //var imageUrl = 'https://1.bp.blogspot.com/-MIiZGYSNw88/YYJgVysOEJI/AAAAAAAAAhc/U5i2aDlc_3QfO4EjaHrwmkAmdEA-kkglACNcBGAsYHQ/s320/Logo%2BBitcoin72ppi.png'
            var imageUrl = 'https://gcolor.github.io/Logo_Bitcoin72ppi.png'
            var imageBounds = [
                [imgDimensions.width, 0],
                [0, imgDimensions.height]
            ];
            L.imageOverlay(imageUrl, imageBounds).addTo(map);

            map.fitBounds(imageBounds);
            map.setView(xy(circle_center_x, circle_center_y), minZoom);

            map.on('zoom', function (e) {
                var currZoom = map.getZoom();
                //console.log(`currZoom888=${currZoom}`)
            })

            map.on('zoomend', function (e) {
                var currZoom = map.getZoom();
                //console.log(`currZoom=${currZoom}`)
                if (currZoom >= showGridByZoom && !isGridVisible()) {
                    //Збільшили
                    showHideGrid(1, true)
                    map.dragging.enable();
                    map.scrollWheelZoom.enable()

                } else if (currZoom <= showGridByZoom && isGridVisible()) {
                    showHideGrid(1, false)
                    //map.dragging.disable();
                }
                if (currZoom < resetPositionZoom) {
                    //debugger
                    map.setView(xy(circle_center_x, circle_center_y), minZoom);
                    map.dragging.disable()
                    map.scrollWheelZoom.disable()
                }
                if (currZoom > resetPositionZoom) {
                    map.dragging.enable()
                }


            });


            //myGreenPinMarker = L.marker([10, 10], { icon: greenIcon, draggable: true }).addTo(map);

            map.on('click', onMapClick);
            map.dragging.disable();
            map.scrollWheelZoom.disable()
        }

        function onMapClick(e) {
            var coord = String(e.latlng).split(',');
            var lat = coord[0].split('(');
            var lng = coord[1].split(')');
            let click_x = Math.floor(Number(lng[0]))
            let click_y = Math.floor(Number(lat[1]))

            let ID = getIDbyXY(click_x, click_y)
            let row_ID = getRowIDbyXY(click_x, click_y)
            let x_id = findRowByID(ID)
            if (map.getZoom() > showGridByZoom) {
                if (x_id && ID) {
                    let pos_x = x_id.x
                    let pos_y = x_id.y
                    let myPinMarker = getOrCreateMarker(markersLayerGroup, pos_x, pos_y)
                    myPinMarker.setTooltipContent(`${ID}`)
                    squaresLayerGroup.clearLayers()
                    myPinMarker.setLatLng(xy(pos_x + 0.5, pos_y + 0.5));
                    draw1pxSquareByID(ID)
                } else {
                    //draw1pxSquare(click_x, click_y, 'Out of circle', { color: 'lime', fillColor: '#787850' })
                }
            }
        }
        //-----------------------------------------
        function addMarker(marker_x, marker_y, layer, params = { icon: svgIcon, title: "", alt: "", draggable: true }, clearSquareLayer = true) {
            /*marker_x,marker_y - координати в Leaflet
            params = { icon: svgIcon, title: "MyPoint", alt: "The Big I", draggable: true }            
            */
            if (clearSquareLayer) {
                squaresLayerGroup.clearLayers()
            }
            let myPinMarker = L.marker([marker_x, marker_y], params).addTo(layer)
            myPinMarker.bindTooltip("", { permanent: true, direction: 'top', className: "my-label", offset: [0, -55] }).openTooltip()
            myPinMarker.on('dragend', function (e) {
                console.log('dragged', e.target._leaflet_id)
                var coord = String(myPinMarker.getLatLng()).split(',');
                var lat = coord[0].split('(');
                var lng = coord[1].split(')');
                let ID = getIDbyXY(Math.floor(Number(lng[0])), Math.floor(Number(lat[1])))
                if (ID) {
                    //myPinMarker.setTooltipContent(`X=${lng[0]} Y=${lat[1]} ID=${ID}`)
                    if (clearSquareLayer) {
                        squaresLayerGroup.clearLayers()
                    }
                    myPinMarker.setTooltipContent(`${ID}`)
                    let x_id = findRowByID(ID)
                    let pos_x = x_id.x
                    let pos_y = x_id.y
                    myPinMarker.setLatLng(xy(pos_x + 0.5, pos_y + 0.5));
                    draw1pxSquareByID(ID)
                } else {
                    myPinMarker.setTooltipContent(`Out of circle`)
                }
            });
            return myPinMarker

        }

        function getMarkerById(ID, layer) {
            console.log(markersLayerGroup)
        }

        function getOrCreateMarker(layer, x, y) {
            let markers = Object.keys(layer._layers)
            if (markers.length > 0) {
                return layer._layers[markers[0]]
            }
            else {
                return addMarker(x, y, layer)
            }
        }


        //----------------------------------------


        function draw1pxSquareByID(ID) {
            let x_id = findRowByID(ID)
            if (x_id) {
                let pos_x = x_id.x
                let pos_y = x_id.y
                draw1pxSquare(pos_x, pos_y, String(ID))
            }
        }



        function draw1pxSquare(startX, startY, text = '', params = { color: 'transparent', fillColor: 'white', opacity: 0.5 }) {
            /*
            Малює квадрат використовуючи координати Leaflet:
            /\Y
            |  
            |  
            |_________>X
            (0;0)
            */
            function isInteger(num) {
                return (num ^ 0) === num;
            }
            startX = isInteger(startX) ? startX + 0.1 : startX
            startY = isInteger(startY) ? startY + 0.1 : startY

            var polygon = L.polygon([
                xy([Math.floor(startX), Math.floor(startY)]),
                xy([Math.ceil(startX), Math.ceil(startY) - 1]),
                xy([Math.ceil(startX), Math.ceil(startY)]),
                xy([Math.floor(startX), Math.ceil(startY)])
            ], {
                color: params.color || 'red',
                fillColor: params.fillColor || '#f0',
                fillOpacity: params.opacity || 0.5
            }).addTo(squaresLayerGroup)
        }

        function drawIDPoint(zoom_value = 0) {
            /*
                Шукає піксель за заданим ІД
                та малює квадрат використвуючи координати Leaflet                
            */
            let id_val = document.getElementById('id_pixel_input').value;
            if (Number.isNaN(Number(id_val))) {
                alert('ONLY numbers ALLOWED')
            } else if (Number(id_val) > 0) {
                let x_id = findRowByID(id_val)
                if (x_id) {
                    map.scrollWheelZoom.enable()
                    squaresLayerGroup.clearLayers()
                    let pos_x = x_id.x
                    let pos_y = x_id.y
                    draw1pxSquare(pos_x, pos_y, String(id_val), { color: 'transparent', fillColor: 'white', opacity: 0.5 })
                    let activeMarker = getOrCreateMarker(markersLayerGroup, pos_x, pos_y)
                    activeMarker.setLatLng(xy(pos_x + 0.5, pos_y + 0.5));
                    activeMarker.setTooltipContent(`${id_val}`)
                    //map.flyTo(xy(circle_center_x, circle_center_y), minZoom, { animate: true, duration: showZoomedPixelDelay });
                    map.setView(xy(circle_center_x, circle_center_y), minZoom, { animate: true, duration: showZoomedPixelDelay });
                    map.panTo(xy(pos_x, pos_y), { animate: true, duration: showZoomedPixelDelay })
                    //plavno(pos_x, pos_y).then(map.setView(xy(pos_x, pos_y), maxZoom, { animate: true, duration: showZoomedPixelDelay }))
                    //map.panTo(xy(pos_x, pos_y), { animate: true, duration: showZoomedPixelDelay })
                    setTimeout(function () {
                        //map.setView(xy(pos_x, pos_y), maxZoom, { animate: true, duration: 6000 })
                        map.flyTo(xy(pos_x, pos_y), maxZoom, { animate: true, duration: showZoomedPixelDelay })
                    }, showZoomedPixelDelay * 1000)
                }
            }
        }

        //******************************************

        function addRow(x, y) {
            let start_y = circle_center_y - Math.floor(circle_diameter) / 2
            let local_x = x - circle_center_x
            let local_y = y - start_y
            //console.log(`x=${x}, y=${y}, start_y=${start_y},local_x=${local_x}, local_y=${local_y}`)
            circle_rows_array.push([local_x, local_y])
        }

        function getVirtualCircleEdgePoints(center_x, center_y, radius) {
            /*
           Отримуємо координати границі кола 
           Координати монітора
           (0;0)----------->(X)
                |
                |
                |
                V(Y)
           */
            var x = radius;
            var y = 0;
            var radiusError = 1 - x;
            circle_rows_array = []
            while (x >= y) {
                addRow(y + center_x, -x + center_y); //1
                addRow(x + center_x, -y + center_y); //2
                addRow(x + center_x, y + center_y); //3
                addRow(y + center_x, x + center_y); //4
                //addRow(-y + center_x, x + center_y); //5
                //addRow(-x + center_x, y + center_y); //6
                //addRow(-x + center_x, -y + center_y);//7
                //addRow(-y + center_x, -x + center_y); //8
                y++;

                if (radiusError < 0) {
                    radiusError += 2 * y + 1;
                } else {
                    x--;
                    radiusError += 2 * (y - x + 1);
                }
            }
        }

        function sortRows() {
            let sorted_rows = circle_rows_array.sort((first, second) => first[0] - second[0]).sort((first, second) => first[1] - second[1])
            //            console.log('SORTED_rows', sorted_rows)
            let circle_rows_array_max = [] //contain max D (X axis)
            prev_row = { x: 0, y: 0 }

            sorted_rows.forEach(item => {
                if (item[1] == prev_row.y) {
                    if (item[0] >= prev_row.x) {
                        prev_row.x = item[0]
                    }
                } else {
                    circle_rows_array_max.push([prev_row.x, prev_row.y, prev_row.x * 2])
                    prev_row.x = item[0]
                    prev_row.y = item[1]
                }
            })
            let last_row = sorted_rows[sorted_rows.length - 1]
            circle_rows_array_max.push([last_row[0], last_row[1], last_row[0] * 2 + 1])
            return circle_rows_array_max
        }

        function updateVirtualCircleModel(circle_rows_array_max, maxID = 21000000) {
            /*
            Оновлюємо віртуальні "круглі" координати
            Через недосконалість алгоритму побудови віртуального круга (отримання граней)
            ми не дополучаємо певну кількість пікселів, тому приходиться використати
            брудний хак прийом:
            додати по одному віртуальному пікселю зліва і зправав певних рядях
                +*
              +*
             +*
            +*
            +*
             +*
              +*
                +*
            */
            let accu = 0
            circle_rows_array_max.forEach(item => {
                accu += item[2]
                virtual_circle_model.push({
                    n: item[1],
                    y: item[1] + circle_center_y - Math.round(circle_diameter) / 2,
                    x_l: circle_center_x - item[0],
                    x_r: circle_center_x + item[0],
                    r_id: accu,
                    l_id: accu - (circle_center_x + item[0]) - (circle_center_x - item[0])
                })
            })
            let min_id = virtual_circle_model[0].r_id
            let max_id = virtual_circle_model[virtual_circle_model.length - 1].r_id
            //recalc right left ID
            accu = 0
            let diff = 0
            let current_max_id = virtual_circle_model[virtual_circle_model.length - 1].r_id
            if (current_max_id < maxID) {
                //add additional pixels

                let missing_pixels = maxID - current_max_id
                let circle_rows = Math.floor(virtual_circle_model.length / 2)
                let rows_to_change = missing_pixels / 2
                //let start_row = Math.abs((circle_rows / 2) - (rows_to_change / 2))
                let start_row = 0
                for (let row = start_row; row <= rows_to_change; row++) {
                    virtual_circle_model[row].x_l = virtual_circle_model[row].x_l - 1
                    virtual_circle_model[row].x_r = virtual_circle_model[row].x_r + 1
                }
            }
            virtual_circle_model.reverse()
            //console.log('REVERSE', virtual_circle_model)
            //----- Додаємо додаткові пікселі
            virtual_circle_model.forEach(item => {
                item.l_id = accu
                diff = item.x_r - item.x_l
                accu = accu + diff
                item.r_id = accu
            })
            //----------------------
            /*virtual_circle_model.forEach(item => {
                item.r_id = max_id - item.r_id + min_id
                item.asder = item.x_r - item.x_l
                item.l_id = item.r_id - (item.x_r - item.x_l)
            })*/
            //console.log('virtual_circle_model', virtual_circle_model)
        }

        function resetVirtualCircle() {
            getVirtualCircleEdgePoints(circle_center_x, circle_center_y, Math.floor(circle_diameter) / 2)
            updateVirtualCircleModel(sortRows())
        }


        function getIDbyXY(abs_x, abs_y) {
            /*
           Отримуємо ID пікселя
           Координати монітора (абсолютні)
           Потрібно враховувати відступи????? Вияснити
           (0;0)----------->(X)
                |
                |
                |
                V(Y)
           */
            //debugger
            let row = virtual_circle_model.filter(item => item.y == abs_y)
            //let row = virtual_circle_model.filter(item => item.y == abs_y - 1)
            if (row.length > 0 && (abs_x >= row[0].x_l && abs_x <= row[0].x_r)) {
                let q_quantity = row[0].x_r - row[0].x_l
                if (q_quantity == 0) {
                    q_quantity = 1
                }
                let q_pos = abs_x - row[0].x_l
                let id = row[0].r_id - q_quantity + q_pos
                return id
            } else {
                return null
            }
        }
        function getRowIDbyXY(abs_x, abs_y) {
            /*
           Отримуємо row ID пікселя
           Координати монітора (абсолютні десятичні 256.00888)
           Потрібно враховувати відступи????? Вияснити
           (0;0)----------->(X)
                |
                |
                |
                V(Y)
           */
            let row = virtual_circle_model.filter(item => item.y == abs_y - 1)
            if (row.length > 0 && (abs_x >= row[0].x_l && abs_x <= row[0].x_r)) {
                let q_quantity = row[0].x_r - row[0].x_l
                if (q_quantity == 0) {
                    q_quantity = 1
                }
                return row[0]
            } else {
                return null
            }
        }

        function findRowByID(id) {
            let row = virtual_circle_model.filter(item => {
                if (id <= item.r_id && id >= item.r_id - (item.x_r - item.x_l)) {
                    return true
                } else {
                    return false
                }
            })
            if (row.length > 0) {
                //console.log('findRowByID row=', row)
                //console.log(`X calculation:  ${row[0].x_r} - (${row[0].r_id} - ${id}) `)
                //let x = row[0].x_r - (row[0].r_id - id) - 1
                let x = row[0].x_r - (row[0].r_id - id)
                row[0].x = x
                //console.log('findRowByID row[0].x=', x)
                return row[0]
            } else return null
        }



        //-------------------------------------------------------

        function hideLeafletLink() {
            document.getElementsByClassName('leaflet-control-attribution leaflet-control')[0].classList.add('hide-leaflet-logo')
        }

        function showHideCross() {
            showCross = !showCross;
            if (showCross) {
                drawCross(circle_center_x, circle_center_y, circle_diameter)
            } else {
                crossLayerGroup.clearLayers()
            }
        }

        function showHideCircle() {
            showCircle = !showCircle;
            if (showCircle) {
                drawCircle(circle_center_x, circle_center_y, circle_diameter, { weight: 2, opacity: 0.01 })
            } else {
                circleLayerGroup.clearLayers()
            }
        }

        function drawCross(x, y, diameter, ext = 5) {
            var vert_line = [
                xy(x, y - Math.ceil(diameter) / 2 - ext),
                xy(x, y + Math.ceil(diameter) / 2 + ext),
            ];
            L.polyline(vert_line, { color: 'blue' }).addTo(crossLayerGroup);
            var hor_line = [
                xy(x - Math.ceil(diameter) / 2 - ext, y),
                xy(x + Math.ceil(diameter) / 2 + ext, y),
            ];
            L.polyline(hor_line, { color: 'blue' }).addTo(crossLayerGroup);
        }

        function drawCircle(x, y, diameter, params) {
            L.circle(xy([x, y]), {
                color: params.color || 'red',
                fillColor: '#f03',
                fillOpacity: params.opacity || 0.1,
                stroke: true,
                weight: params.weight || 2,
                radius: diameter / 2 + 0.4
            }).addTo(circleLayerGroup);
        }



        function drawImageBoards() {
            L.polygon([
                xy([0, 0]),
                xy([0, image_height]),
                xy([image_width, image_height]),
                xy([image_width, 0]),

            ]).addTo(map)
        }

        function isGridVisible() {
            return gridLayerGroup.getLayers().length > 0
        }

        function showHideGrid(cellSize = 50, show = null) {
            if (show == true) {
                gridLayerGroup.clearLayers()
                drawGrid(cellSize)
                //console.log(gridLayerGroup.getLayers().length)
            }
            if (show == false) {
                gridLayerGroup.clearLayers()
                //console.log(gridLayerGroup.getLayers().length)
            }
            if (show === null) {
                showGrid = !showGrid
                if (showGrid) {
                    drawGrid(cellSize)
                } else {
                    gridLayerGroup.clearLayers()
                }
            }
        }

        function drawGrid(cellSize = 50, color = '#bd6e0fe5', weight = 1) {
            for (let col = 0; col <= image_width + 1; col += cellSize) {
                L.polyline([xy(col, 0), xy(col, image_width)], { color: color, weight: weight }).addTo(gridLayerGroup);

            }
            for (let row = 0; row < image_width + 1; row += cellSize) {
                L.polyline([xy(0, row), xy(image_width, row)], { color: color, weight: weight }).addTo(gridLayerGroup);
            }
        }

        function clearMyLayer() {
            console.log(markersLayerGroup)
            //markersLayerGroup.clearLayers()
        }

        function showMyPolygons() {
            console.log(squaresLayerGroup)
            squaresLayerGroup.clearLayers()
        }

        function goHack() {
            console.log(map)
            map.setView(xy(circle_center_x, circle_center_y), -3.5);
        }

        //------------------------------------------------------------

        initLMap()
        hideLeafletLink()
        resetVirtualCircle();
        //drawImageBoards()

        //addMarker(10, 10, markersLayerGroup)


        /*virtual_circle_model.forEach(item => {
            draw1pxSquareByID(item.r_id)
        })*/
    </script>

</body>

</html>